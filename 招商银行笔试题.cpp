第一题：三位数转 逆序的二进制编码
小招喵是一个商业巨腕，手下有n个公司，每-一个公司他
都对其有一个三位数编码，但是他现在想到了一种新的
编码方式。
即原来的三位数的每一位数字0~9， 对应成4位二进制编
码，例如1对应0001, 2对应0010， 5对应0101, 9对应1001.
那么三位数(可能小于百， 默认前导为0)
例如:
123对应000100100011
891对应100010010001
76对应00001110110
5对应00000000101
小招喵为了让别人不觉得他的新编码太没新意，他要求
上述编码后的二进制串进行镜像反转(首尾反转)，并且去
除前导0，作为最终编码。小招喵忙于管理公司，让你帮
做。

输入：

1
10 1 2 3 123 5 8 999 777 156 95
输出：

1
100000000000 10000000000 110000000000 110001001000 101000000000 100000000 100110011001 111011101110 11010101000  101010010000


难点一：十进制转二进制编码现推

难点二：字符串位数不够 怎么补全， ljust()、rjust()函数

难点三：找到字符串中第一个指定元素的索引 find()函数

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
第二题：字母填充序列
■题目描述
小招喵想要把k种不同的小写字母填到长度为n的序列中，对于每个小写字母，他可以使用多次，并且这k种字母都要出现，同时他还需要保证任意两个相邻的字母不相同。小招喵想知道此时字典序最小的方案是什么，或者这根本不可能得到。

输入描述:

1
两个整数n,k。分别表示序列长度以及字符集大小 1≤ n ≤105,  1≤ k ≤26
输出描述:

1
若不存在一个合法的方案，则输出-1 否则输出一行字符串表示答案
示例1：
输入输出示例仅供调试，后台判题数据一般不包含示例
输入：

6 2
输出：

ababab

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
n,k = [int(item) for item in input().strip().split()]
if n < k:
  print(-1)
elif n == k:
  ans = ''
  for i in range(1,n+1):
      ans += chr(i + 96)
  print(ans)
else:
  kk = k - 2
  ans = ''
  for i in range(n-kk):
      if i % 2 == 0:
          ans += 'a'
      else:
          ans += 'b'
  for i in range(3, 3+kk):
      ans += chr(i + 96)
  print(ans)
第三题：最大收益
题目描述
一开始有一 个大小为s的史莱姆，每次可以从现有的史莱
姆中选择一个大小大于 1的史莱姆，设它的大小为k，将它分裂成a和k- a(1≤a
给定s, m,求最少分裂几次才能得到至少m的收益，如果无法达到输出-1。
输入描述:
一行两个数字s, m.
输出描述：
一行一个数字表示答案

示例1、输入输出示例仅供调试， 后台判题数据一般不包
含示例
输入
333 43434

输出
4


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22