
// lowbit。 lowbit(a) = a & ((~a) + 1)
/*
    t[x] 保存以x为根的子树中叶结点值的和。
    进一步观察
    t[x] 结点覆盖的长度就是lowbit(x);
    t[x] 节点的父节点为 t[x + lowbit(x)]
    整棵树的深度，为log(n) + 1;
    t[x] = ∑a[i]
        i = x - lowbit(x) + 1

    此时add(x, k)
        void add(int x, int k){
            for(; x<=n; x+= (x & -x)){
                t[x] += k;
            }
        }
    ask(7)
        int ask(int x){
            int ans = 0;
            for(; x; x -= (x & -x)) ans += t[x];
            return ans;
        }
    
    总结：树状数组是一个动态维护前缀和的工具，需要灵活运用。
    
    单点修改、区间查询
        单点修改-->修改原数组的单个值。
        区间查询-->查询前缀和。
    区间修改、单点查询（区间修改每一个值，单点查询
        区间修改-->修改原数组一个区间内的每一个单个值。
        单点查询-->查询该点前缀和。

        //注意：差分数组不包含本身值。

        差分数组b。用树状数组维护b的前缀和，即a[]的每个元素增量。
        区间增加时候，[l, r] + d
            --> add(l, d)  add(r+1, -d);
        查询单点值的时候 a[x]
            ans = a[x] + ask(x);    
    区间修改、区间查询
        区间修改-->修改原数组一个区间内的每一个单个值。
        区间查询-->求得多个前缀和的和。每一个是一个单个前缀和。

        与前面区间修改相同
        ∑b[i] --> a[x]增量
            i = 1~x
        ∑∑b[i] --> a[x]前缀和的增量

*/